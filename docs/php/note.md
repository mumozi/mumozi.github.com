# 常见知识点

## **单双引号区别：（单引号效率更高）**

- 单引号不能解析变量；双引号解析变量，变量可以使用特殊字符{}
- 单引号不能解析转义字符，只能解析单引号和反斜线；双引号可以解析所有转义字符
- 点号连接

## **定义常量**

- Const 更快语言结构，常量定义
- Define 函数

## **正则表达式**

- 作用：分割查找匹配替换
- 分隔符：正斜线（/）hash符号（#）取反符号（~）
- 通用原子：\d(十进制的0-9)、\D、\w（数字字母下划线）、\W、\s（空白符）、\S
- 元字符：.*?^$+{n}{n,}{n,m}[]()[^]|[-]
- 模式修正符：i m e s U x A D u

## **MySQL数据库考点、**

**基础操作、存储引擎、锁机制、事务处理、存储过程、触发器**

 

## InnoDB表引擎

- l 事务型引擎，性能优秀
- l 数据存储在共享表空间，可以通过配置分开
- l 主键查询的性能高于其他类型的存储引擎
- l 内部优化，从磁盘读取数据时自动在内存建立hash索引，插入数据时自动构建插入缓冲区
- l 通过一些机制和工具支持真正的热备份
- l 支持崩溃后的安全恢复
- l 支持行级锁
- l 支持外键

## MyISAM表引擎

- l 5.1版本之前是默认的存储引擎
- l 拥有全文索引、压缩、空间函数
- l 不支持事务和行级锁，不支持崩溃后的安全恢复
- l 表存储在两个文件，MYD和MYI（数据跟索引）
- l 设计简单，某些场景下性能很好

## **MySQL锁机制**

- l 多个查询同一时刻进行数据修改时，就会发生并发控制的问题
- l 共享锁和排他锁，就是读锁和写锁

## **锁粒度**

- l 表锁，系统性能开销最小，会锁定整张表。MyISAM使用表锁
- l 行锁，最大程度的支持并发处理，带来最大的锁开销，InnoDB实现行级锁

## **事务处理**

**存储过程+使用场景**

- l 通过把处理封装在容易使用的单元中，简化复杂的操作

- l 保证数据的一致性

- l 简化对变动的管理


## **触发器+使用场景**

提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程

- l 可通过数据库中的相关表实现级联更改

- l 实时监控某张表中的某个字段的更改而需要作出相应的处理

- l 某些业务编号的生成等

- l 滥用会造成数据库及应用程序的维护困难




## **索引对性能的影响**

- l 大大减少服务器需要扫描的数据量

- l 帮助服务器避免排序和临时表

- l 将随机I/O变顺序I/O

- l 大大提高查询速度，降低写的速度、占用磁盘


**索引的类型**

- l 一个表只能有一个主键索引，可以有多个唯一索引

- l 主键索引一定是唯一索引，唯一索引不是主键索引

- l 主键可以与外键构成参照完整性约束，防止数据不一致


组合索引：将多个列组合在一起创建索引，可以覆盖多个列

外键索引：只有InnoDB类型的表才可以使用外键索引，保证税局的一致性、完整性和实现级联操作

全文索引：MySQL自带的全文索引只能用于MyISAM，并且只能对英文进行全文检索

## **索引的创建原则**

- l 最适合索引的列是出现在where子句的列，或连接子句中的列而不是出现在select关键字后的列

- l 索引列的基数越大，索引的效果越好

- l 对字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间

- l 根据情况进行创建复合索引，符合索引可以提高查询效率

- l 避免创建过多索引，索引会额外占用磁盘空间，降低写操作效率

- l 主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用，提高查询效率


## **索引的注意事项**

- l 复合索引遵循前缀原则

- l like查询，%不能再前，可以使用全文索引

- l column is null 可以使用索引

- l 如果mysql估计使用索引比全表扫描更慢，会放弃使用索引

- l 如果or前的条件中的列有索引，后面没有，索引都不会被用到

- l 列类型是字符串，查询时一定要给值加引号，否则会失效


## **分析sql查询慢的方法**

l 记录慢查询日志

分析查询日志，不要打开慢查询日志进行分析，使用pt-query-disgest工具进行分析

l 使用show profile

set profiling = 1;开启，服务器上执行的所有语句会检测消耗的时间，存到临时表里

show profiles

show profile for query 临时表ID

l 使用show status

show status 会返回一些计数器，show global status 查看服务器级别的所有计数

有时根据这些计数，可以猜测出哪些操作代价较高或者消耗时间多

l 使用show processlist

观察是否有大量线程处于不正常的状态或者特征

l 使用explain

分析单条sql语句

## **优化查询过程中的数据访问**

- l 访问数据太多导致查询性能下降

- l 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列

- l 确认mysql服务器是否存在分析大量不必要的数据行

- l 避免使用如下sql语句


a)   查询不需要的记录，使用limit解决

b)   多表关联返回全部列，指定A.id,A.name,B.age

c)   总是取出全部列，select * 会让优化器无法完成索引覆盖扫描的优化

d)   重复查询相同的数据，可以缓存数据，下次直接读取缓存

l 是否在扫描额外的记录

使用explain来进行分析，如果发现查询需要扫描大量的数据但只返回少数的行，可以通过如下技巧优化：

a)   使用索引覆盖扫描，把所有用的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果

b)   改编数据库和表的结构，修改数据表范式

c)   重写sql语句，让优化器可以以更优的方式执行查询

## **优化长难的查询语句**

l 切分查询——将一个大的查询分为多个小的相同的查询

l 分解关联查询——可以将一条关联语句分解成多条sql来执行

a)   让缓存的效率更高

b)   执行单个查询可以减少锁的竞争

c)   在应用层做关联可以更容易对数据库进行拆分

d)   查询效率会有大幅提升

e)   较少冗余记录的查询

## **优化特定类型的查询语句**

l 优化count()查询

count(*)中的*会忽略所有的列，直接统计所有列数，因此不要使用count（列名）

增加汇总表

使用缓存

l 优化关联查询

确定on或者using子句的列上有索引

确保group by 和order by 中只有一个表的列，这样mysql才有可能使用索引

l 优化子查询

尽可能使用关联查询来替代

l 优化group by和distinct

这两种查询均可以使用索引来优化，是最有效的优化方法

关联查询中，使用标识列进行分组的效率会更高

如果不需要order by，进行group by时使用order by null，mysql不会再进行文件排序

With rollup超级聚合，可以挪到应用程序处理

l 优化limit分页

limit偏移量打的时候，查询效率较低

可以记录上次查询的最大ID，下次查询时直接根据该ID来查询

l 优化union查询

union all 的效率高于union

## **分区表的原理**

- l 对于用户而言，分区表是一个独立的逻辑表，但是底层mysql将其分成了多个物理子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件

- l 创建表时使用partition by 子句定义每个分区存放的数据，执行查询时，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询只需要查询所需数据在的分区即可

- l 分区的主要目的是将数据按照一个较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且如果想一次性删除整个分区的数据也很方便


## **分区表的适用场景**

- l 表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据

- l 分区表的数据更易维护，可以对独立的分区进行独立的操作

- l 分区表的数据可以分布在不同的机器上，从而高校使用资源

- l 可以使用分区表来避免某些特殊的瓶颈

- l 可以备份和恢复独立的分区


## **分区表的限制**

- l 一个表最多只能有1024个分区

- l 5.2版本中，分区表表达式必须是整数，5.5可以使用列分区

- l 分区字段中如果有主键和唯一索引列，那么主键列和唯一列都必须包含进来

- l 分区表中无法使用外键约束

- l 需要对现有表的结构进行修改

- l 所有分区都必须使用相同的存储引擎

- l 分区函数中可以使用的函数和表达式会有一些限制

- l 某些存储引擎不支持分区（mysql都支持）

- l 对于myisam的分区表，不能使用load index into cache

- l 对于myisam表，使用分区表时需要打开更多的文件描述符


**分库分表的原理**

通过一些hash算法或者工具实现将一张数据表垂直或者水平进行物理切分

**分库分表的适用场景**

- l 单表记录条数达到百万到千万级别时

- l 解决表锁的问题


**分表方式**

l 水平分割

表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度

1)   表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用

2)   需要吧数据存档在多个介质上

水平分表缺点

1)   给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需union操作

2)   在许多数据库应用中，这种复杂性会超过它带来的优点，查询时会增加读一个索引层的磁盘次数

l 垂直分表

把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中

1)   如果一个表中某些列常用，而另外一些列不常用

2)   可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数

垂直分表缺点

​     管理冗余列，查询所有数据需要join操作

 **分表缺点**

l 有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改编，整个分表逻辑都会改变，扩展性较差

l 对于应用层来说，逻辑算法无疑增加开发成本

## **MYSQL主从复制工作原理**

- l 在主库上吧数据更改记录到二进制日志

- l 从库将主库的日志复制到自己的中继日志

- l 从库读取中继日志中的事件，将其重放到从库数据中


## **Mysql主从复制解决的问题**

- l 数据分布：随意停止或开始复制，并在不同地理位置分布数据备份

- l 负载均衡：降低单个服务器的压力

- l 高可用和故障切换：帮助应用程序避免单点失败

- l 升级测试：可以使用更高版本的mysql作为从库

## **==与===区别**

​    ===比较两个变量的值和类型；==比较两个变量的值，不比较数据类型。

## PHP引号使用规则

Php中尽量使用单引号，HTML代码要用双引号；

字符串的值引用符号；

包含变量的时候，用双引号可以简化；

复杂的时候用大括号

不需要加入变量或者单引号和反斜杠时。用单引号引字符串

##  Redis、Memecached 这两者有什么区别？

1. Redis 支持更加丰富的数据存储类型，String、Hash、List、Set 和     Sorted Set。Memcached 仅支持简单的 key-value 结构。
2. Memcached     key-value存储比 Redis 采用 hash 结构来做 key-value 存储的内存利用率更高。
3. Redis 提供了事务的功能，可以保证一系列命令的原子性
4. Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中
5. Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。

## 如何解决优化网站App大数据大流量高并发

- 硬件方面
- 软件方面
- 禁止外部盗链
- 控制大文件的下载
- 负载均衡
- 分布式
- 集群
- 主从数据库
- 分布式数据库
- 分布式缓存

## **TCP** **三次握手**

三次握手就是客户端与服务器端建立TCP连接时需要发送3个包进行连接的确认，在三次握手完成后即可建立连接。

- 第一次握手。客户端发送请求报文，标志位SYN设置为1，随机产生seq值为x，客户端进入SYN_SENT状态，等待服务器端的回应。
- 第二次握手。服务器端接收到请求报文，将SYN和ACK都设置为1，ack为x+1，随机产生seq值为y，然后将数据包发送给客户端进行确认，服务器端进入SYN_RCVD状态。
- 第三次握手。客户端收到回应的数据包后，确认ack是否为x+1，以及ACK是否为1，若正确，则将ACK设置为1，ack为y+1，然后将数据发送给服务器端。服务器端在接受到数据后检查ack是否为y+1，ACK是否为1，若正确则正确建立连接，双方均进入ESTAB-LISHED状态，完成三次握手。
-  

## **TCP** **与 UDP 的区别**

除了TCP之外，我们还常听到的是UDP，那么他俩有啥区别呢？
 TCP对应的是可靠性要求高的应用，从上面的解释可以看出来，在真正通信之前要三次握手，是面向连接的；并且TCP利用序列号保证消息的有序性。
 而UDP对应的则是可靠性要求低，但是流量大、速度快的应用；和TCP相比，UDP是无连接的并且可能是无序的。
 TCP更重量，UDP更轻量，没有高低之分，只是应用的场景不同。

## 如何理解MVC

MVC设计模式（Model模型-View视图-Controller控制器）一种软件架构模式
 控制器负责处理用户的请求（包括数据模型的调用以及对表现层的输出控制）
 模型负责处理具体的业务逻辑
 视图负责展示结果给用户

## 子类重写父类的protected方法有什么限制？

1. final修饰的类方法不可被子类重写
2. 5.3以后方法参数个数必须一致
3. 重写时访问级别只可以等于或者宽松于当前重写方法的访问级别

## 【真题4】多态与方法重写有什么关系？

答案：多态是指一个类可以被多个类继承，每个子类都可以对父类方法进行重写，每个类里的同名方法可以实现不同的功能从而表现出多种形态，它增强了软件的灵活性和重用性。
 重写是子类对父类中的方法进行改写。它们的关系是重写让类具备多态性。

## 【真题1】 什么是面向对象？其主要特征是什么？

答案：面向对象是程序的一种设计方式，它是一种对现实世界的理解和抽象的方法，它可以提高程序的重用性，让程序结构更加清晰。
 面向对象的主要特征为：封装、继承、多态。

## 面向对象编程的五个基本原则 (S.O.L.I.D)

1. ### SRP 单一功能原则 (你可以这样干，并不是说你应该这样干)

   - 引起类变化的因素永远不要多余一个，保证类的有且只有一个责任

2. ### OCP 开闭原则 (开胸手术时不需要穿一件外套)

   - 对扩展开放，对修改闭合

3. ### LSP 里氏替换原则

   - 当一个子类的实例应该能够替换任何其父类的实例时，它们之间才具有IS-A关系

4. ### ISP 接口隔离原则

   - 不要强迫客户端（泛指调用者）去依赖那些他们不使用的接口

5. ### DIP 依赖反转原则

   - 高层模块不应该依赖底层模块，两者都应该依赖其抽象
   - 抽象不应该依赖于细节，细节应该依赖于抽象

## 【真题3】 请简单说明PHP的垃圾收集机制。

答案：在PHP中，当没有任何变量指向该对象时，该对象变为垃圾将会在内存中被销毁，可以防止内存溢出。内存中对变量有引用计数，当计数到0时变量被销毁。

## MYSQL优化方案有哪些？

1. 选用适合的字段类型，避免数据库增加不必要的空间，字段尽量设定为NOTNULL，类似性别，省份尽量使用枚举类型ENUM
2. 使用JOIN查询代替子查询
3. 使用UNION代替临时表
4. 尽量不使用外键、除非必须保持数据表与表之间的一致性、完整性
5. 尽量不使用视图
6. 分表分库，读写分离

7. 合理设置主键及索引
   - 索引分为：普通索引、唯一索引、全文索引、主键（也是一种唯一索引）

8. 后期演变的数据表优化

- 垂直拆分：表数据拆分到不同表中，按照业务拆分
- 水平拆分：行数据拆分到不同表中，按照时间、类型、身份等因素拆分表
- 水平垂直联合拆分


9.索引建立原则

  - 最左前缀匹配原则
  - 索引列尽量不参与计算
  - 尽量扩展索引不要新建索引

## PHP中传引用与传值的区别？

- 按值传递：函数内对值的内容改变对函数外部无影响
- 引用传递：函数内对值的内容改变在函数外部也会做出相应修改

## POST和GET有什么区别

1. GET是从服务器上获取数据，POST是向服务器传送数据
2. GET是通过发送HTTP协议通过URl参数传递进行接收，而POST是实体数据，通过表单提交
3. GET传送的数据量较小，不能大于2KB。POST传送的数据量较大，一般被默认为不受限制。
4. GET安全性非常低，POST安全性较高

## session与cookie的区别

1. session存储在服务器上的php指定目录中(session_dir)的位置
2. cookie存储在客户端

**明细：**

### 1、cookie和session原理及区别  

cookie``采用的是客户端的会话状态的一种储存机制。它是服务器在本地机器上存储的小段文本或者是内存中的一段数据，并随每一个请求发送至同一个服务器。
session``是一种服务器端的信息管理机制，它把这些文件信息以文件的形式存放在服务器的硬盘空间上（这是默认情况，可以用memcache把这种数据放到内存里面）当客户端向服务器发出请求时，要求服务器端产生一个session时，服务器端会先检查一下，客户端的cookie里面有没有session_id，是否过期。如果有这样的session_id的话，服务器端会根据cookie里的session_id把服务器的session检索出来。如果没有这样的session_id的话，服务器端会重新建立一个。PHPSESSID是一串加了密的字符串，它的生成按照一定的规则来执行。同一客户端启动二次session_start的话，session_id是不一样的。 
区别：Cookie保存在客户端浏览器中，而Session保存在服务器上。Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。

### 2 、session产生的session_id放在cookie里面，如果用户把cookie禁止掉，是不是session也不能用了呢？

禁止掉cookie后，session当然可以用，不过通过其他的方式来获得这个sessionid，比如，可以跟在url的后面，或者以表单的形势提交到服务器端。从而使服务器端了解客户端的状态。

### 3、为什么说session 比cookie更安全？

真正的cookie存在于客户端硬盘上的一个文本文件，如果两者一样的话，只要cookie就好了，让客户端来分提服务器的负担，并且对于用户来说又是透明的。但实际上不是。
session``的sessionID是放在cookie里，要想功破session的话，得分两步：
第一要得到sessionID。攻破cookie后，你要得到sessionID,sessionID是要有人登录，或者启动session_start才会有，你不知道什么时候会有人登录。
第二取有效sessionID。sessionID是加密的，第二次session_start的时候，前一次的sessionID就没有用了，session过期时sessionid也会失效，想在短时间内功破加了密的 sessionID很难。session是针对某一次通信而言，会话结束session也就随着消失了。

## 说几个你所知道的设计模式

### 单例模式

- 保证一个类仅有一个实例，并提供一个访问他的全局访问点例如框架中的数据库连接 - 类似DB类

### 策略模式

- 针对一组算法，将每一个算法封装到具有共同接口的独立的类中，例如进入个人主页时，根据浏览者的不同，给予不同的显示与操作 - 类似不同用户呈现不同效果

### 注册模式

- 提供了在程序中有条理的存放并管理一组全局对象 (object) - 类似服务提供者的注入

### 适配器模式

- 将不同接口适配成统一的API接口，例如数据操作有mysql、mysqli、pdo等，可利用适配器模式统一接口

### 观察者模式

- 一个对象通过添加一个方法使本身变得可观察。当可观察的对象更改时，它会将消息发送到已注册的观察者。例如实现实现消息推送 - 将所有类的实例化注册到一个数组，通过循环批量执行类

### 装饰器模式

- 不修改原类代码和继承的情况下动态扩展类的功能，例如框架的每个Controller文件会提供before和after方法 - 在某个方法或输出之前执行或之后执行，用于修饰

### 迭代器模式

- 提供一个方法顺序访问一个聚合对象中各个元素，在PHP中将继承 Iterator 类 – yield

## **HTTPS和HTTP的区别主要为以下四点：**

一、https协议需要到ca申请证书，一般免费证书很少，需要交费。

二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。

三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## 请写出自少三种截取文件名后缀的方法或函数（PHP原生函数和自己实现函数均可）

```php
$file = 'x.y.z.png';
$ext = substr(strrchr($file, '.'), 1);
$ext = pathinfo($file)['extension'];
$ext = array_pop(explode('.', $file));
```

## 【真题11】 定义类成员的访问权限控制符有哪些？默认修饰符是什么？

答案：类成员的访问修饰符有public、private、protected，主要用来修饰类中的成员属性和方法。public是公共类型，允许在类的内部或子类中使用，也可以在类外部被访问。private是私有类型，只能在类的内部被使用，不能被继承使用。protected是保护类型，只能在类的内部或子类中使用。如果不使用public、private、protected等关键字修饰方法或属性，那么可以使用var关键字，它的功能等同于public，可以在类内或类外被调用，也可以被继承使用。
 其中，PHP默认的修饰符是public，即公有类型。
 类前面只能加final、abstract关键字，被final修饰的属性或方法是不能被继承的，只能在当前类中使用，abstract定义的类或方法，叫作抽象类或抽象方法。
 属性前面：必须有访问修饰符（private，protected，public，var）。

## 【真题12】 PHP的魔术方法包含哪些（越多越好）？在什么情况下被自动调用？

答案：PHP可用的魔术方法会在特定情况下被自动调用，但是前提是特定的条件被触发，并且这些魔术方法可以在类中作为方法。

###  PHP的魔术方法有：

 1）_construct()：构造函数，创建对象时自动被调用。
 2）_destruct()：析构函数，对象的所有引用都被删除或者当对象被显式销毁时执行。
 3）__clone()：克隆函数，调用clone方法时自动调用。
 4）__set()：当程序试图写入一个不存在或不可见的成员变量时自动调用。该函数在类中定义时必须有两个参数：变量名和变量值。
 5）__get()：当程序调用一个未定义或不可见的成员变量时自动调用__get()来读取变量值。定义时必有有一个参数：变量名。
 6）__call()：当程序试图调用不存在或不可见的成员方法时，自动调用__call()。__call()方法一般用于监视错误的方法调用。为了避免当调用的方法不存在时产生错误，可以使用__call()方法来避免。该方法包含两个参数：方法名和方法参数。其中，方法参数以数组形式存在。
 7）__sleep()：使用serialize()实现序列化对象时，先调用该方法，可以用来清除对象并返回一个该对象中所有变量的数组。
 8）__wakeup()：使用unserialize()还原一个被序列化的对象时，先执行该方法，恢复在序列化中可能丢失的数据库连接及相关工作。
 9）__toString()：当使用echo或print输出对象时，将对象转化为字符串。
 10）__autoload()：调用未被实例化的类时，自动调用，在指定路径下查找和该类名称相同的文件。

## 【真题16】什么是抽象类和接口？抽象类和接口有什么不同和相似的地方？

答案：被关键字abstract修饰的类叫作抽象类，抽象类是不能被实例化的。被abstract修饰的方法为抽象方法，一个类只要有一个抽象方法，这个类一定是抽象类。
 接口是通过关键字interface来定义的，可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体实现。PHP类只支持是单重继承的，但通过接口可以实现PHP类的多重继承。
 抽象类和接口的不同和相似的地方如下所示。
 1）抽象类是一种不能被实例化的类，只能作为其他类的父类来使用。
 2）抽象类是通过关键字abstract来声明的。
 3）抽象类与普通类相似，都包含成员变量和成员方法，两者的区别在于，抽象类中至少要包含一个抽象方法。
 4）抽象方法没有方法体，该方法就是要被子类重写的。
 5）抽象方法的格式为：abstract function abstractMethod()。
 6）因为PHP中只支持单重继承，所以如果想实现多重继承，那么就要使用接口。也就是说，子类可以实现多个接口。
 7）接口类是通过interface关键字来声明的，接口类中的成员变量和方法都是public的，可以不用显式地使用public来修饰。
 8）接口中的方法没有方法体。接口中的方法就是要被子类继承实现的。
 9）子类继承抽象类使用extends关键字，子类实现接口使用implements关键字。

## 【真题19】php中public、protected、private三种访问控制模式的区别是什么？

参考答案：php中public、protected、private三种访问控制模式的区别如下：
 访 问 模 式 描 述
 public 共有，任何地方都可以访问
 protected 继承，只能在本类或子类中访问，在其他地方不能使用
 private 私有，只能在本类中访问，在其他地方不能使用

## 提高网站访问速度的9个要点

- 冗余的网站代码

- 缩减图片大小和数量。

- 减少JavaScript脚本文件

- 尽量外部调用JS代码，不要放在网页中，更不要远程调用外部的JS代码。可以尝试结合的JavaScript和压缩他们更快地加载。有些时候我们在头部的CSS，JS代码太 多，导致中间内容部分加载太慢，所以尽量减少头部代码。

- 删除冗余插件

- 利用缓存插件


很多站长构架网站已经不再自己写程序，而是使用比较完善的现成开源程序作为框架结构，比如用到WORDPRESS，提高网站速度，有时就需要使用缓存插件来实现。比如WP- Supercache，W3-TotalCache这两款插件是我们常会安装的缓存插件，可以有效的提高网站速度。

- 运用静态的HTML页面


**网站外部影响因素也不容小嘘：**

- 挑选优质的虚拟主机

- 使用CDN加速

- 开启GZip压缩功能。


## [sql性能优化](https://www.cnblogs.com/lddbupt/p/5781831.html)

- **分析复杂的SQL语句**
- **开启缓存查询**
- **尽量用join代替子查询**

- **尽量避免select \***
- **常用查询字段建索引**
- **避免update全部字段**

## sql优化方法 

1. 优化业务数据
2. 优化数据设计
3. 优化流程设计
4. 优化sql语句
5. 优化物理结构
6. 优化内存分配
7. 优化I/O
8. 优化内存竞争
9. 优化操作系统

 