## 自定义组件

开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。——[自定义组件](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/)

### 创建与使用自定义组件

#### 创建自定义组件

自定义组件和Page一样，都是由 wxml、wxss、js、json四个文件组成。这四个文件的具体作用也是和 Page 保持一致的，但一些配置(json)和使用方法(js)略有差异，我们可以通过微信开发者工具或者使用安装了小程序开发插件的 IDE 来快速创建一个自定义组件，不推荐手动去自定义组件所需的文件。

#### 使用自定义组件

要使用一个自定义组件，我们只需要在需要使用的页面或者另一个自定义组件的`.json`文件中声明一下：

```json
 "usingComponents": {
    "i-tabs": "/components/tabs/index"
 }
```

其中，自定义组件使用的名称是可以随意起的，但需要遵循一定的命名规范，只能是小写字母、中划线和下划线的组合，不能以`wx-`为前缀。推荐的命名方式是用纯小写的字母或者单词，多个字母或者单词之间使用`-`分割。

如果一个自定义组件会在项目中多个页面或者其他自定义组件中使用，推荐在`app.json`中的`usingComponents`属性配置这个声明，这样页面或者其他自定义组件在使用这个自定义组件的时候就不需要再重复声明。

其他配置同理，小程序中有很多页面配置也是全局配置中存在的，如果这个配置本身就是应该全部统一的或者大多数情况下统一的，那么就应该在全局配置中配置，个别差异的页面，可以在页面的.json 文件中重复配置来覆盖全局配置（页面配置的优先级比全局配置高）。

声明之后，就可以在 wxml 文件中，像使用基础组件一样使用自定义组件了：

```html
<view>
    <i-tabs></i-tabs>
</view>
```

### 自定义组件特性

封装、继承、多态

这里借用一下`面向对象`的三大特性，因为我想不到有什么其他更贴切的描述了。也因为如此，如果你是一个接触过面向对象概念的开发者，那么你会一下子理解到自定义组件的精髓。

#### 封装

我们把原本放在 Page 中的元素，封装到了自定义组件中。同时，自定义组件还能具备逻辑处理和样式定义的能力，因为它同样支持 js 和wxss 编写。也就是说，理论上自定义组件就是一个可以独立完成某个功能的模块。通过封装自定义组件，我们可以实现某些功能的快速复用，减少重复代码实现，同时简化我们的 Page 页面结构。

#### 继承

我们在实际工程实践中，有时候会碰到一种情况，就是多个不同的组件，它们有相同的属性和组件方法，但同时又有一些特有的属性和方法，这时候我们可以利用自定义组件的[behaviors](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html)机制，来实现属性和组件方法的复用，这一特性我们将会在后续课程内容中实践到。

#### 多态

有些自定义组件，我们为了让组件更加通用和易于扩展，我们会实现自定义组件部分必要的页面内容，然后利用[插槽Slot](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html)机制来实现让自定义组件的调用方决定要展示的内容。

### 自定义组件使用场景

是否使用自定义组件，有两个前提，当满足其中一个的时候，就要考虑使用自定义组件：

1. Page 页面结构复杂、冗长（可读性差，不利于维护和扩展）

2. 重复实现（同样的功能代码散布在项目的各个地方是工程实践中的巨坑，我们要尽量避免出现这种代码）

但是考虑归考虑，具体是不是要做自定义组件的封装我们还需要慎重考虑。因为在实际开发过程中，你可能会被工期、业务理解、技术水平等诸多因素影响导致你不会去使用自定义组件，这里推荐阅读课程电子书课后阅读章节中的`《自定义组件封装实践要点》`文章，能给你在工程实践中起到很好的参考。

### 通用组件与业务组件

自定义组件根据使用场景的不同，大体分为`通用组件`和`业务组件`两种。

通用组件就类似我们本章节实现的`Tabs`，另外还有我们后续课程内容中会实践的`Button`、`Icon`、`badge`组件等。通用组件的最大特点就是不和具体业务实现关联，它本身的独立性很强，自己就是一个相对完整的功能。我们只需要通过给组件传递参数或者插入内容到插槽就能实现在不同业务场景下的使用，通用组件因为对通用性要求比较高，所以在设计和实现的难度上也会比较考验开发者的设计能力和编码能力。

业务组件是相对通用性没那么高的自定义组件，通常这类组件会和具体业务实现关联。主要作用是在于简化复杂 Page 页面的页面结构，并且支持在特定业务场景下的复用，后续课程内容中也会有相关实践。

### 自定义组件通信

[组件间通信与事件](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html)

1. 页面或者父组件通过属性给自定义组件传递参数。

2. 自定义组件通过触发事件给页面或者父组件传递参数。

这个与 Vue 组件通信模式是一样的。

## WXS

WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。——[WXS](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/)

### 创建与使用 WXS

#### 创建 WXS

我们可以在微信开发者工具或者 IDE 中，直接新建一个文件，只需要指定文件的后缀名为`.wxs`即可创建一个 WXS 文件。

#### 使用 WXS

WXS 支持两种使用方式，一种是创建单独的`.wxs`文件，然后在 wxml 文件中引入这个 wxs 文件，这也是我们课程中使用的方式。另一种方式是可以直接在 wxml 文件中书写，但通常请下不推荐使用这种方式来使用 wxs，这里引用小程序开发文档中的一段示例代码：

```js
<!--wxml--><!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 --><wxs module="m1">
var getMax = function(array) {
  var max = undefined;
  for (var i = 0; i < array.length; ++i) {
    max = max === undefined ?
      array[i] :
      (max >= array[i] ? max : array[i]);
  }
  return max;
}
 
module.exports.getMax = getMax;</wxs>
<!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array --><view> {{m1.getMax(array)}} </view>
 
```

这种方式有两个缺点，第一，降低了 Page 的可读性；第二，无法在其他页面复用该 wxs 的实现。

更多关于 WXS 的语法请参考[WXS语法参考](https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/)

### 使用 WXS 的注意事项

这里引用小程序开发文档中的内容：

1. WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。

2. WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。

3. WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。

4. WXS 函数不能作为组件的事件回调。

5. 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。

这里再补充两点：

1. 只能使用 JavaScript 的 ES5 语法。

2. 可以支持console.log来调试，但是调试体验非常差。考虑到一般 WXS 里面不会书写特别复杂的 JS 逻辑，建议是在外部页面测试好逻辑之后，复制粘贴到 WXS 中。

### WXS 的使用场景

当为了实现某个功能，会导致视图层与逻辑层频繁交互时，就需要考虑是否能使用 WXS 来代替这部分的实现。比如以下两种场景：

1. 需要在 WXML 中对数据进行较复杂的格式化或者转换。

有些时候我们需要对 WXML 中的数据做一些特殊的格式化处理。最简单的实现就是在 js 中处理好，然后执行数据绑定渲染到 wxml上。这种做法多数情况下不是什么太大的问题。但是在比较好的工程实践中，这种处理就应该被封装起来，每个组件或者页面的 JS 都应该体现`单一职责`，即只做跟自己确切相关的事。但同学们可能会觉得，我们封装一个处理函数，然后引用，只做数据绑定不就可以了？是的，但这并没有解决视图层与逻辑层多余的交互问题。我们完全可以把这件事，都放在渲染层去做。WXML 本身是支持一些简单的逻辑运算的，比如我们在课程中就试过在 WXML 中使用 if、for、三元表达式。但一些比较复杂的逻辑运算，我们就需要借助 WXS 了，因为在 WXS 中我们可以编写相对复杂的 JS 代码，并且可以直接作用到 WXML 中，省去了数据绑定的过程。

1. 引用微信开发文档中一个很好的例子：有频繁用户交互的效果在小程序上表现是比较卡顿的，例如页面有 2 个元素 A 和 B，用户在 A 上做 touchmove 手势，要求 B 也跟随移动，[movable-view](https://developers.weixin.qq.com/miniprogram/dev/component/movable-view.html) 就是一个典型的例子。

一次 touchmove 事件的响应过程为：
 a、touchmove 事件从视图层（Webview）抛到逻辑层（App Service）
 b、逻辑层（App Service）处理 touchmove 事件，再通过 setData 来改变 B 的位置
 一次 touchmove 的响应需要经过 2 次的逻辑层和渲染层的通信以及一次渲染，通信的耗时比较大。此外 setData 渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。

像这种频繁的触发事件又做数据绑定的，使用 WXS 可以明显的提升性能。我们可以把事件的处理函数定义在 WXS 中，在 WXS里面进行逻辑处理，只在必要时才通过触发事件或者调用页面/组件方法来进行视图层和逻辑层的通信

### WXS 通信

1. 最简单的情况下，使用 WXS 中的函数来做数据处理，并且是有返回值的，那么 WXML 在调用WXS 中的函数后，就能拿获取到返回值。

```js
<!--wxml--><!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 --><wxs module="m1">
var getMax = function(array) {
  var max = undefined;
  <!-- 省略一些逻辑 -->
  return max;
}
 
module.exports.getMax = getMax;</wxs>
<!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array --><view> {{m1.getMax(array)}} </view>
 
```

1. 使用 WXS 中的函数来响应小程序事件，可以通过使用ownerInstance.callMethod(‘函数名’,‘参数’)来调用页面/组件的函数，并给这个方法传递参数。

WXS 所在的组件或者页面，必须已经存在要调用的函数。

1. 使用 WXS 中的函数来响应小程序事件，可以通过使用ownerInstance.triggerEvent(‘事件名称’, ‘参数’)来触发一个自定义事件。

想要监听到这个事件，必须是在使用了这个WXS的自定义组件外部，即父组件或者页面，才能监听到。